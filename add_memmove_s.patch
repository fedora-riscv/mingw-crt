From d51b0c6477f1ce5ca2cc0377be239339327fa252 Mon Sep 17 00:00:00 2001
From: Ruben De Smet <ruben.de.smet@telenet.be>
Date: Mon, 28 Jul 2014 21:15:57 +0200
Subject: [PATCH] Add secapi wrapper for memmove_s

---
 mingw-w64-crt/Makefile.am         |  1 +
 mingw-w64-crt/Makefile.in         | 73 ++++++++++++++++++++++++++++++++++-----
 mingw-w64-crt/lib32/msvcrt.def.in |  2 +-
 mingw-w64-crt/lib64/msvcrt.def.in |  2 +-
 mingw-w64-crt/secapi/memmove_s.c  | 60 ++++++++++++++++++++++++++++++++
 5 files changed, 128 insertions(+), 10 deletions(-)
 create mode 100644 mingw-w64-crt/secapi/memmove_s.c

diff --git a/mingw-w64-crt/secapi/memmove_s.c b/mingw-w64-crt/secapi/memmove_s.c
new file mode 100644
index 0000000..a7b8501
--- /dev/null
+++ b/mingw-w64-crt/secapi/memmove_s.c
@@ -0,0 +1,60 @@
+#include <windows.h>
+#include <malloc.h>
+#include <errno.h>
+#include <msvcrt.h>
+
+errno_t __cdecl memmove_s (void *, size_t, const void *, size_t);
+static errno_t __cdecl _int_memmove_s (void *, size_t, const void *, size_t);
+static errno_t __cdecl _stub (void *, size_t, const void *, size_t);
+
+errno_t __cdecl (*__MINGW_IMP_SYMBOL(memmove_s))(void *, size_t, const void *, size_t) = 
+ _stub;
+
+static errno_t __cdecl
+_stub (void *d, size_t dn, const void *s, size_t n)
+{
+  errno_t __cdecl (*f)(void *, size_t, const void *, size_t) = __MINGW_IMP_SYMBOL(memmove_s);
+
+  if (f == _stub)
+    {
+	f = (errno_t __cdecl (*)(void *, size_t, const void *, size_t))
+	    GetProcAddress (__mingw_get_msvcrt_handle (), "memmove_s");
+	if (!f)
+	  f = _int_memmove_s;
+	__MINGW_IMP_SYMBOL(memmove_s) = f;
+    }
+  return (*f)(d, dn, s, n);
+}
+
+errno_t __cdecl
+memmove_s (void *d, size_t dn, const void *s, size_t n)
+{
+  return _stub (d, dn, s, n);
+}
+
+static errno_t __cdecl
+_int_memmove_s (void *d, size_t dn, const void *s, size_t n)
+{
+  if (!n)
+    return 0;
+
+  if (!d || !s)
+    {
+      if (d)
+        memset (d, 0, dn);
+      errno = EINVAL;
+      return EINVAL;
+    }
+
+  if (dn < n)
+    {
+      memset (d, 0, dn);
+
+      errno = ERANGE;
+      return ERANGE;
+    }
+
+  memmove (d, s, n);
+
+  return 0;
+}
-- 
1.8.3.1


